<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>KYNDO ‚Äî Memory (Nivel 1)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <style>
    body { margin: 0; font-family: Arial, sans-serif; background: #fff; }
    header { padding: 12px; text-align: center; border-bottom: 1px solid #ccc; }
    footer { padding: 12px; text-align: center; }

    #board { display: grid; gap: 7px; padding: 8px; }

    .card {
      aspect-ratio: 1 / 1;
      background: #bdbdbd;
      border-radius: 6px;
      display: flex;
      align-items: center;
      justify-content: center;
      user-select: none;
      cursor: pointer;
      font-weight: bold;
      color: rgba(0,0,0,0.75);
    }

    .card.hidden { background: #bdbdbd; }
    .card.hidden::after { content: "K"; font-size: 14px; color: rgba(0,0,0,0.3); }

    .card.revealed { background: #ffffff; border: 1px solid #999; }
    .card.pending { background: #e8e8e8; border: 1px dashed #aaa; }
    .card.matched {
      background: #f1f1f1;
      border: 2px solid #aaa;
      opacity: 0.65;
      pointer-events: none;
      transform: scale(0.96);
      transition: transform 120ms ease;
      cursor: default;
    }

    /* OVERLAY (FOCO CARTA) */
    #overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.6);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 100;
    }
    #overlay.active { display: flex; }

    .focused-card {
      width: 90vw;
      max-width: 350px;
      max-height: 88vh;
      aspect-ratio: 2 / 3;
      background: #fff;
      border-radius: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
      box-shadow: 0 10px 30px rgba(0,0,0,0.25);
    }

    .card-front {
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
    }

    .card-image {
      flex: 3;
      background: #e0e0e0;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
      font-weight: bold;
    }

    .card-name {
      flex: 1;
      border-top: 1px solid #ccc;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      font-size: 14px;
    }

    .card-stats {
      flex: 1;
      border-top: 1px solid #ccc;
      display: flex;
      justify-content: space-around;
      align-items: center;
      font-size: 13px;
    }

    /* OVERLAY RESULTADO (FIN DE GRADO) */
    #resultOverlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.65);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 200;
      padding: 16px;
    }
    #resultOverlay.active { display: flex; }

    .result-card {
      width: min(520px, 92vw);
      background: #fff;
      border-radius: 12px;
      padding: 16px 16px 12px;
      box-shadow: 0 12px 40px rgba(0,0,0,0.30);
      text-align: center;
    }
    .result-title { font-size: 18px; font-weight: bold; margin-bottom: 8px; }
    .result-sub { font-size: 13px; opacity: 0.85; margin-bottom: 10px; }
    .result-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
      margin: 10px 0 12px;
      font-size: 13px;
      text-align: left;
    }
    .result-row {
      border: 1px solid #e6e6e6;
      border-radius: 10px;
      padding: 10px;
      background: #fafafa;
    }
    .result-row b { display: block; font-size: 12px; opacity: 0.75; margin-bottom: 4px; }

    .btn {
      border: 0;
      border-radius: 10px;
      padding: 10px 12px;
      font-weight: bold;
      cursor: pointer;
      width: 100%;
      margin-top: 8px;
    }
    .btn-primary { background: #111; color: #fff; }
    .btn-ghost { background: #efefef; color: #111; }

    @media (min-width: 720px) {
      .btn { width: auto; min-width: 180px; margin: 8px 6px 0; }
    }
  </style>
</head>

<body>

<header>
  <h1 style="margin:0 0 6px;">Memory</h1>
  <div id="hud" style="font-size:14px; opacity:.85;">
    üß† <span id="hud-matches">0</span>/<span id="hud-pairs">0</span>
    &nbsp; üîÅ <span id="hud-attempts">0</span>/<span id="hud-maxAttempts">0</span>
    &nbsp; üî• <span id="hud-streak">0</span>
    &nbsp; ‚≠ê <span id="hud-score">0</span>
  </div>
  <div style="font-size:12px; opacity:.7; margin-top:6px;">
    Grado: <span id="hud-grade">1</span>
  </div>
</header>

<section id="board"></section>

<footer>
  <a href="../">Volver al Home</a>
</footer>

<!-- Overlay de foco (carta grande) -->
<div id="overlay">
  <div class="focused-card">
    <div class="card-front">
      <div class="card-image" id="focusImage">KYNDO</div>
      <div class="card-name" id="focusName">‚Äî</div>
      <div class="card-stats">
        <span id="focusAtk">ATK ‚Äî</span>
        <span id="focusDef">DEF ‚Äî</span>
      </div>
    </div>
  </div>
</div>

<!-- Overlay fin de grado -->
<div id="resultOverlay">
  <div class="result-card">
    <div class="result-title" id="resultTitle">‚Äî</div>
    <div class="result-sub" id="resultSub">‚Äî</div>

    <div class="result-grid">
      <div class="result-row"><b>Pares</b><span id="resultPairs">‚Äî</span></div>
      <div class="result-row"><b>Intentos</b><span id="resultAttempts">‚Äî</span></div>
      <div class="result-row"><b>Puntaje</b><span id="resultScore">‚Äî</span></div>
      <div class="result-row"><b>Racha m√°x.</b><span id="resultMaxStreak">‚Äî</span></div>
    </div>

    <div style="margin-top:6px;">
      <button class="btn btn-primary" id="btnPrimary">Continuar</button>
      <button class="btn btn-ghost" id="btnSecondary">Reintentar</button>
    </div>
  </div>
</div>

<script>
document.addEventListener('DOMContentLoaded', () => {

  // =========================
  // ‚úÖ PAR√ÅMETROS DE BALANCE (EDITABLES)
  // =========================
  const STREAK_BASE_BONUS = 5;              // controla qu√© tan fuertes son los bonos de racha (5 = lo que definiste)
  const REPEAT_MISS_EXTRA_ATTEMPTS = 1;     // +1 intento extra al repetir un par fallado
  const REPEAT_MISS_POINT_PENALTY = 2;      // -2 puntos al repetir un par fallado
  const ATTEMPT_FACTOR = 2.2;               // maxAttempts = totalPairs * factor (Nivel 1)

  // =========================
  // ‚úÖ CONFIG DE GRADO (EDITABLE)
  // =========================
  const gradeConfig = {
    1: 20,
    2: 30,
    3: 42,
    4: 56,
    5: 72
  };

  // Persistencia simple (por ahora local)
  const STORAGE_KEY = 'kyndo_memory_v1';
  const saved = (() => { try { return JSON.parse(localStorage.getItem(STORAGE_KEY) || '{}'); } catch { return {}; } })();
  let memoryGrade = typeof saved.memoryGrade === 'number' ? saved.memoryGrade : 1;
  if (!gradeConfig[memoryGrade]) memoryGrade = 1;

  // =========================
  // DOM
  // =========================
  const board = document.getElementById('board');
  const overlay = document.getElementById('overlay');
  const resultOverlay = document.getElementById('resultOverlay');

  const hudMatches = document.getElementById('hud-matches');
  const hudPairs = document.getElementById('hud-pairs');
  const hudAttempts = document.getElementById('hud-attempts');
  const hudMaxAttempts = document.getElementById('hud-maxAttempts');
  const hudStreak = document.getElementById('hud-streak');
  const hudScore = document.getElementById('hud-score');
  const hudGrade = document.getElementById('hud-grade');

  const focusImage = document.getElementById('focusImage');
  const focusName = document.getElementById('focusName');
  const focusAtk = document.getElementById('focusAtk');
  const focusDef = document.getElementById('focusDef');

  const resultTitle = document.getElementById('resultTitle');
  const resultSub = document.getElementById('resultSub');
  const resultPairs = document.getElementById('resultPairs');
  const resultAttempts = document.getElementById('resultAttempts');
  const resultScore = document.getElementById('resultScore');
  const resultMaxStreak = document.getElementById('resultMaxStreak');
  const btnPrimary = document.getElementById('btnPrimary');
  const btnSecondary = document.getElementById('btnSecondary');

  // =========================
  // Estado de partida
  // =========================
  let totalCards = 0;
  let totalPairs = 0;
  let maxAttempts = 0;

  let score = 0;
  let matches = 0;
  let attempts = 0;

  let streak = 0;
  let maxStreakSeen = 0;

  let revealedCards = []; // max 2
  let pendingLock = false; // evita clicks raros mientras overlay est√° activo

  // Memoria de errores (pares fallados)
  // clave can√≥nica: "minId-maxId"
  const missedPairs = new Set();

  // =========================
  // Helpers
  // =========================
  function clampNonNegative(n) { return n < 0 ? 0 : n; }

  function updateHUD() {
    hudMatches.textContent = String(matches);
    hudPairs.textContent = String(totalPairs);
    hudAttempts.textContent = String(attempts);
    hudMaxAttempts.textContent = String(maxAttempts);
    hudStreak.textContent = String(streak);
    hudScore.textContent = String(score);
    hudGrade.textContent = String(memoryGrade);
  }

  function canonicalPairKey(id1, id2) {
    const a = Number(id1), b = Number(id2);
    return a < b ? `${a}-${b}` : `${b}-${a}`;
  }

  function computeColumns(cards) {
    return Math.ceil(Math.sqrt(cards));
  }

  function buildObjectIds(pairs) {
    const ids = [];
    for (let i = 0; i < pairs; i++) { ids.push(i); ids.push(i); }
    // Fisher‚ÄìYates
    for (let i = ids.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [ids[i], ids[j]] = [ids[j], ids[i]];
    }
    return ids;
  }

  function openFocusFor(card) {
    // Contenido m√≠nimo para pruebas (visible + recordable)
    const oid = Number(card.dataset.objectId);

    // "contenido" ficticio para prueba
    const fakeName = `AVE ${oid + 1}`;
    const fakeAtk = 10 + (oid % 9);
    const fakeDef = 10 + ((oid + 3) % 9);

    focusImage.textContent = `üúÅ ${oid + 1}`;
    focusName.textContent = fakeName;
    focusAtk.textContent = `ATK ${fakeAtk}`;
    focusDef.textContent = `DEF ${fakeDef}`;

    overlay.classList.add('active');
  }

  function closeFocus() {
    overlay.classList.remove('active');
  }

  function showResultOverlay(passed) {
    const pairsText = `${matches}/${totalPairs}`;
    const attemptsText = `${attempts}/${maxAttempts}`;
    const scoreText = `${score}`;
    const maxStreakText = `${maxStreakSeen}`;

    resultPairs.textContent = pairsText;
    resultAttempts.textContent = attemptsText;
    resultScore.textContent = scoreText;
    resultMaxStreak.textContent = maxStreakText;

    if (passed) {
      resultTitle.textContent = 'Nivel superado';
      resultSub.textContent = 'Eficiencia confirmada. El tablero sube de grado.';
      btnPrimary.textContent = 'Continuar';
      btnPrimary.style.display = '';
      btnSecondary.textContent = 'Reintentar (opcional)';
      btnSecondary.style.display = '';
    } else {
      resultTitle.textContent = 'Nivel completado, pero no superado';
      resultSub.textContent = 'Te pasaste del m√°ximo de intentos. Para subir, debes completarlo dentro del l√≠mite.';
      btnPrimary.textContent = 'Reintentar';
      btnPrimary.style.display = '';
      btnSecondary.textContent = 'Cerrar';
      btnSecondary.style.display = '';
    }

    resultOverlay.classList.add('active');

    btnPrimary.onclick = () => {
      resultOverlay.classList.remove('active');
      if (passed) {
        // sube grado
        const next = memoryGrade + 1;
        memoryGrade = gradeConfig[next] ? next : memoryGrade; // si no existe, se queda
        localStorage.setItem(STORAGE_KEY, JSON.stringify({ memoryGrade }));
      }
      startRun(); // reinicia con grado actual (o incrementado)
    };

    btnSecondary.onclick = () => {
      resultOverlay.classList.remove('active');
      if (!passed) {
        // cerrar solo deja ver el tablero terminado (sin avanzar)
        // Si quiere reintentar, usa el bot√≥n principal
        return;
      }
      // en "pasado": reintentar opcional
      startRun();
    };
  }

  function checkEndOfLevel() {
    if (matches !== totalPairs) return;

    const passed = attempts <= maxAttempts;
    // peque√±a pausa cognitiva
    setTimeout(() => showResultOverlay(passed), 350);
  }

  // =========================
  // Motor de intento (resolver 2 cartas)
  // =========================
  function resolvePair(a, b) {
    // 1 intento normal siempre que se eval√∫a una pareja
    attempts += 1;

    const aId = Number(a.dataset.objectId);
    const bId = Number(b.dataset.objectId);

    const isMatch = aId === bId;

    if (isMatch) {
      // MATCH
      matches += 1;

      // racha
      streak += 1;
      if (streak > maxStreakSeen) maxStreakSeen = streak;

      // puntos base
      score += 10;

      // bono acumulativo por racha (tu sistema), parametrizable
      // bono del "paso" actual = STREAK_BASE_BONUS * (streak - 1)
      // (para racha 1 => 0)
      const stepBonus = STREAK_BASE_BONUS * (streak - 1);
      score += stepBonus;

      a.dataset.state = 'matched';
      b.dataset.state = 'matched';
      a.classList.remove('revealed');
      b.classList.remove('revealed');
      a.classList.add('matched');
      b.classList.add('matched');

      revealedCards = [];
      updateHUD();
      checkEndOfLevel();
      return;
    }

    // NO MATCH
    // racha se rompe
    streak = 0;

    // castigo por repetir el mismo par fallado (desde la primera repetici√≥n)
    const key = canonicalPairKey(aId, bId);
    if (missedPairs.has(key)) {
      attempts += REPEAT_MISS_EXTRA_ATTEMPTS; // +1 intento extra
      score = clampNonNegative(score - REPEAT_MISS_POINT_PENALTY); // -2 pts
    } else {
      missedPairs.add(key);
    }

    // pasar a pending
    [a, b].forEach(card => {
      card.dataset.state = 'pending';
      card.classList.remove('revealed');
      card.classList.add('pending');
    });

    revealedCards = [];
    updateHUD();
  }

  // =========================
  // Run (crear tablero por grado)
  // =========================
  function startRun() {
    // reset UI/estado
    board.innerHTML = '';
    missedPairs.clear();
    revealedCards = [];
    pendingLock = false;

    score = 0;
    matches = 0;
    attempts = 0;
    streak = 0;
    maxStreakSeen = 0;

    totalCards = gradeConfig[memoryGrade];
    totalPairs = totalCards / 2;
    maxAttempts = Math.ceil(totalPairs * ATTEMPT_FACTOR);

    // grid din√°mico (bloque)
    const columns = computeColumns(totalCards);
    board.style.gridTemplateColumns = `repeat(${columns}, 1fr)`;

    // crear ids mezclados
    const objectIds = buildObjectIds(totalPairs);

    // crear cartas
    for (let i = 0; i < totalCards; i++) {
      const card = document.createElement('div');
      card.className = 'card hidden';
      card.dataset.state = 'hidden';
      card.dataset.objectId = String(objectIds[i]);

      card.addEventListener('click', (ev) => {
        ev.stopPropagation();
        if (pendingLock) return;

        // si hay 2 pending visibles, obligamos a limpiar antes de seguir
        const pending = board.querySelectorAll('.card.pending');
        if (pending.length === 2) return;

        if (card.dataset.state !== 'hidden') return;
        if (revealedCards.length >= 2) return;

        card.dataset.state = 'revealed';
        card.classList.remove('hidden');
        card.classList.add('revealed');

        revealedCards.push(card);

        // abrir foco siempre
        openFocusFor(card);
      });

      board.appendChild(card);
    }

    updateHUD();
  }

  // =========================
  // Eventos globales
  // =========================
  overlay.addEventListener('click', () => {
    // cerrar foco
    closeFocus();

    // si ya hay dos reveladas, resolver
    if (revealedCards.length === 2) {
      const [a, b] = revealedCards;
      resolvePair(a, b);
    }
  });

  // click extra para limpiar pending y continuar (Nivel 1)
  board.addEventListener('click', () => {
    const pending = board.querySelectorAll('.card.pending');
    if (pending.length === 2) {
      pending.forEach(card => {
        card.dataset.state = 'hidden';
        card.classList.remove('pending');
        card.classList.add('hidden');
      });
    }
  });

  // Arranque
  startRun();

});
</script>

</body>
</html>
