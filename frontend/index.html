<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8" />
    <title>Kindo</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="description" content="Kindo - Juego cognitivo de memoria con sistema de progresión" />

    <!-- Estilos -->
    <link rel="stylesheet" href="styles.css" />
</head>

<body>

<div class="page-shell">
    <header>
        <div class="header-bar">
            <a class="brand-link" href="../index.html">
                <div class="brand-block">
                    <h1 class="brand-title">Kindo</h1>
                    <div class="brand-subtitle">Pairs</div>
                </div>
            </a>

            <div class="hud-block" aria-label="Estadísticas del juego">
                <div class="hud-row hud-meta">
                    <span>Nivel <span id="hud-level">1</span></span>
                    <span>Grado <span id="hud-grade">1</span></span>
                </div>
                <div class="hud-row">
                    <span>Pares <span id="hud-matches">0</span>/<span id="hud-pairs">0</span></span>
                    <span>Intentos <span id="hud-attempts">0</span>/<span id="hud-maxAttempts">0</span></span>
                </div>
                <div class="hud-row">
                    <span>Errores <span id="hud-errors">0</span></span>
                    <span>Racha <span id="hud-streak">0</span></span>
                    <span class="hud-score-highlight">Puntos <span id="hud-score">0</span></span>
                </div>
            </div>

            <div class="actions-block">
                <div id="user-info">
                    <div class="player-info" id="current-player">
                        <div class="player-avatar">&#128100;</div>
                        <div class="player-name">Jugador</div>
                    </div>
                    <div class="player-info" id="opponent-player" style="display: none;">
                        <div class="player-avatar">&#128100;</div>
                        <div class="player-name">Oponente</div>
                    </div>
                </div>
                <a href="deck.html" class="btn btn-ghost" style="margin-top:8px;font-size:13px;">&#127183; Mis Cartas</a>
                <button class="btn btn-ghost" id="btnHistory" style="margin-top:8px;font-size:13px;">&#128196; Partidas</button>
            </div>
        </div>
        <div id="loading">
            Cargando cartas... &#9203;
        </div>
    </header>

    <section id="board"></section>

    <footer>
        <a href="../">Volver al Home</a>
    </footer>
</div>

<!-- Overlay de foco (carta grande) -->
<div id="overlay">
    <div class="focused-card">
        <div class="card-front">
            <div class="card-image" id="focusImage">KYNDO</div>
            <div class="card-name" id="focusName"></div>
            <div class="card-stats">
                <span id="focusAtk">ATK </span>
                <span id="focusDef">DEF </span>
            </div>
        </div>
    </div>
</div>

<!-- Overlay historial de partidas -->
<div id="historyOverlay" style="position:fixed;inset:0;background:rgba(0,0,0,0.72);display:none;align-items:center;justify-content:center;z-index:300;padding:16px;backdrop-filter:blur(6px);">
  <div style="width:min(560px,94vw);background:rgba(255,255,255,0.97);border-radius:18px;padding:20px 18px 14px;box-shadow:0 8px 30px rgba(0,0,0,0.2);max-height:80vh;display:flex;flex-direction:column;">
    <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:12px;">
      <strong style="font-size:16px;">&#128196; Mis Partidas</strong>
      <button id="btnHistoryClose" style="border:0;background:none;font-size:20px;cursor:pointer;color:#555;">&times;</button>
    </div>
    <div id="historyList" style="overflow-y:auto;flex:1;font-size:13px;"></div>
  </div>
</div>

<!-- Overlay fin de grado -->
<div id="resultOverlay">
    <div class="result-card">
        <div class="result-title" id="resultTitle"></div>
        <div class="result-sub" id="resultSub"></div>

        <div class="result-grid">
            <div class="result-row"><b>Pares</b><span id="resultPairs"></span></div>
            <div class="result-row"><b>Intentos</b><span id="resultAttempts"></span></div>
            <div class="result-row"><b>Puntaje</b><span id="resultScore"></span></div>
            <div class="result-row"><b>Racha máx.</b><span id="resultMaxStreak"></span></div>
        </div>

        <div style="margin-top:6px;">
            <button class="btn btn-primary" id="btnPrimary">Continuar</button>
            <button class="btn btn-ghost" id="btnSecondary">Reintentar</button>
        </div>
    </div>
</div>

<!-- Motor del juego -->
<script>
// ===========================
// WEB AUDIO — SONIDOS
// ===========================
const _audioCtx = (() => {
    try { return new (window.AudioContext || window.webkitAudioContext)(); } catch { return null; }
})();

function playTone(freq, duration, type = 'sine', gain = 0.18) {
    if (!_audioCtx) return;
    const osc = _audioCtx.createOscillator();
    const gainNode = _audioCtx.createGain();
    osc.connect(gainNode);
    gainNode.connect(_audioCtx.destination);
    osc.type = type;
    osc.frequency.setValueAtTime(freq, _audioCtx.currentTime);
    gainNode.gain.setValueAtTime(gain, _audioCtx.currentTime);
    gainNode.gain.exponentialRampToValueAtTime(0.001, _audioCtx.currentTime + duration);
    osc.start();
    osc.stop(_audioCtx.currentTime + duration);
}

function soundMatch() {
    playTone(523, 0.12); // C5
    setTimeout(() => playTone(659, 0.12), 100); // E5
    setTimeout(() => playTone(784, 0.2), 200);  // G5
}

function soundError() {
    playTone(200, 0.15, 'sawtooth', 0.12);
    setTimeout(() => playTone(160, 0.2, 'sawtooth', 0.1), 140);
}

document.addEventListener('DOMContentLoaded', async () => {

    // ===========================
    // PARÁMETROS DE BALANCE (EDITABLES)
    // ===========================
    const STREAK_BASE_BONUS = 5;           // bono acumulativo por racha
    const REPEAT_MISS_EXTRA_ATTEMPTS = 1;  // +1 intento al repetir un par fallado
    const REPEAT_MISS_POINT_PENALTY = 2;   // -2 puntos al repetir un par fallado
    const ATTEMPT_FACTOR = 2.2;            // maxAttempts = totalPairs * factor

    // ===========================
    // CONFIG DE GRADO (EDITABLE)
    // ===========================
    const gradeConfig = {
        1: 20,
        2: 30,
        3: 42,
        4: 56,
        5: 72
    };

    // Persistencia simple (local)
    const STORAGE_KEY = 'kyndo_memory_v1';
    const HISTORY_KEY = 'kyndo_history_v1';
    const saved = (() => { try { return JSON.parse(localStorage.getItem(STORAGE_KEY) || '{}'); } catch { return {}; } })();
    let memoryGrade = typeof saved.memoryGrade === 'number' ? saved.memoryGrade : 1;
    if (!gradeConfig[memoryGrade]) memoryGrade = 1;

    function saveMatchToHistory(entry) {
        const history = (() => { try { return JSON.parse(localStorage.getItem(HISTORY_KEY) || '[]'); } catch { return []; } })();
        history.unshift(entry);
        if (history.length > 50) history.length = 50; // máx 50 entradas
        localStorage.setItem(HISTORY_KEY, JSON.stringify(history));
    }

    function getHistory() {
        try { return JSON.parse(localStorage.getItem(HISTORY_KEY) || '[]'); } catch { return []; }
    }

    // ===========================
    // CARGA DE CARTAS REALES
    // ===========================
    let cardCatalog = [];
    const loadingEl = document.getElementById('loading');
    try {
        const res = await fetch('../birds/pack-1.json');
        const data = await res.json();
        cardCatalog = data.assets || [];
    } catch (e) {
        console.warn('No se pudo cargar el mazo de cartas:', e);
    }
    loadingEl.style.display = 'none';

    // ===========================
    // DOM
    // ===========================
    const board = document.getElementById('board');
    const overlay = document.getElementById('overlay');
    const resultOverlay = document.getElementById('resultOverlay');
    const historyOverlay = document.getElementById('historyOverlay');
    const historyList = document.getElementById('historyList');
    const btnHistory = document.getElementById('btnHistory');
    const btnHistoryClose = document.getElementById('btnHistoryClose');

    const hudMatches = document.getElementById('hud-matches');
    const hudPairs = document.getElementById('hud-pairs');
    const hudAttempts = document.getElementById('hud-attempts');
    const hudMaxAttempts = document.getElementById('hud-maxAttempts');
    const hudErrors = document.getElementById('hud-errors');
    const hudStreak = document.getElementById('hud-streak');
    const hudScore = document.getElementById('hud-score');
    const hudGrade = document.getElementById('hud-grade');

    const focusImage = document.getElementById('focusImage');
    const focusName = document.getElementById('focusName');
    const focusAtk = document.getElementById('focusAtk');
    const focusDef = document.getElementById('focusDef');

    const resultTitle = document.getElementById('resultTitle');
    const resultSub = document.getElementById('resultSub');
    const resultPairs = document.getElementById('resultPairs');
    const resultAttempts = document.getElementById('resultAttempts');
    const resultScore = document.getElementById('resultScore');
    const resultMaxStreak = document.getElementById('resultMaxStreak');
    const btnPrimary = document.getElementById('btnPrimary');
    const btnSecondary = document.getElementById('btnSecondary');

    // ===========================
    // Estado de partida
    // ===========================
    let totalCards = 0;
    let totalPairs = 0;
    let maxAttempts = 0;

    let score = 0;
    let matches = 0;
    let attempts = 0;

    let streak = 0;
    let maxStreakSeen = 0;
    let seriousErrors = 0;

    let revealedCards = []; // max 2
    let pendingLock = false;

    // Memoria de errores (pares fallados)
    const missedPairs = new Set();

    // ===========================
    // Helpers
    // ===========================
    function clampNonNegative(n) { return n < 0 ? 0 : n; }

    function updateHUD() {
        hudMatches.textContent = String(matches);
        hudPairs.textContent = String(totalPairs);
        hudAttempts.textContent = String(attempts);
        hudMaxAttempts.textContent = String(maxAttempts);
        hudErrors.textContent = String(seriousErrors);
        hudStreak.textContent = String(streak);
        hudScore.textContent = String(score);
        hudGrade.textContent = String(memoryGrade);
    }

    function canonicalPairKey(id1, id2) {
        const a = Number(id1), b = Number(id2);
        return a < b ? `${a}-${b}` : `${b}-${a}`;
    }

    function computeColumns(cards) {
        return Math.ceil(Math.sqrt(cards));
    }

    function buildObjectIds(pairs) {
        const ids = [];
        for (let i = 0; i < pairs; i++) { ids.push(i); ids.push(i); }
        // Fisher-Yates
        for (let i = ids.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [ids[i], ids[j]] = [ids[j], ids[i]];
        }
        return ids;
    }

    function getCardData(oid) {
        if (cardCatalog.length > 0) {
            return cardCatalog[oid % cardCatalog.length];
        }
        return { id: `ave-${oid}`, title: `Ave ${oid + 1}`, image_url: null };
    }

    function openFocusFor(card) {
        const oid = Number(card.dataset.objectId);
        const cardData = getCardData(oid);

        const name = cardData.title || `Ave ${oid + 1}`;
        const imageUrl = cardData.image_url ? `../${cardData.image_url}` : null;
        const atk = 10 + (oid % 9);
        const def = 10 + ((oid + 3) % 9);

        if (imageUrl) {
            focusImage.innerHTML = `<img src="${imageUrl}" alt="${name}" style="width:100%;height:100%;object-fit:cover;border-radius:8px;">`;
        } else {
            focusImage.textContent = `\uD83C\uDFB4 ${oid + 1}`;
        }
        focusName.textContent = name;
        focusAtk.textContent = `ATK ${atk}`;
        focusDef.textContent = `DEF ${def}`;

        overlay.classList.add('active');
    }

    function closeFocus() {
        overlay.classList.remove('active');
    }

    function showResultOverlay(passed) {
        resultPairs.textContent = `${matches}/${totalPairs}`;
        resultAttempts.textContent = `${attempts}/${maxAttempts}`;
        resultScore.textContent = `${score}`;
        resultMaxStreak.textContent = `${maxStreakSeen}`;

        // Guardar en historial
        saveMatchToHistory({
            date: new Date().toISOString(),
            grade: memoryGrade,
            pairs: matches,
            totalPairs,
            attempts,
            maxAttempts,
            score,
            maxStreak: maxStreakSeen,
            passed
        });

        if (passed) {
            resultTitle.textContent = '\uD83C\uDF89 \u00A1Nivel Superado! \uD83C\uDF89';
            resultSub.textContent = '\u00A1Excelente trabajo! Has demostrado gran habilidad. El tablero avanza al siguiente grado.';
            btnPrimary.textContent = '\u2B06\uFE0F Continuar al Siguiente Nivel';
            btnPrimary.style.display = '';
            btnSecondary.textContent = 'Reintentar (opcional)';
            btnSecondary.style.display = '';
            resultOverlay.classList.add('celebration');
        } else {
            resultTitle.textContent = 'Nivel completado, pero no superado';
            resultSub.textContent = 'Te pasaste del m\u00E1ximo de intentos. Para subir, debes completarlo dentro del l\u00EDmite.';
            btnPrimary.textContent = 'Reintentar';
            btnPrimary.style.display = '';
            btnSecondary.textContent = 'Cerrar';
            btnSecondary.style.display = '';
            resultOverlay.classList.remove('celebration');
        }

        resultOverlay.classList.add('active');

        btnPrimary.onclick = () => {
            resultOverlay.classList.remove('active');
            resultOverlay.classList.remove('celebration');
            if (passed) {
                const oldGrade = memoryGrade;
                const next = memoryGrade + 1;
                memoryGrade = gradeConfig[next] ? next : memoryGrade;
                localStorage.setItem(STORAGE_KEY, JSON.stringify({ memoryGrade }));

                if (memoryGrade > oldGrade) {
                    hudGrade.classList.add('grade-up');
                    setTimeout(() => hudGrade.classList.remove('grade-up'), 1000);
                }
            }
            startRun();
        };

        btnSecondary.onclick = () => {
            resultOverlay.classList.remove('active');
            if (!passed) {
                return; // cerrar solo deja ver el tablero terminado
            }
            startRun(); // en "pasado": reintentar opcional
        };
    }

    function checkEndOfLevel() {
        if (matches !== totalPairs) return;
        const passed = attempts <= maxAttempts;
        setTimeout(() => showResultOverlay(passed), 350);
    }

    // ===========================
    // LIMPIEZA DE PENDING (CRÍTICO)
    // ===========================
    function clearPendingCards() {
        const pending = board.querySelectorAll('.card.pending');
        if (pending.length === 2) {
            pending.forEach(card => {
                card.dataset.state = 'hidden';
                card.classList.remove('pending');
                card.classList.add('hidden');
            });
            return true; // se limpiaron
        }
        return false; // no había nada que limpiar
    }

    // ===========================
    // Motor de intento (resolver 2 cartas)
    // ===========================
    function resolvePair(a, b) {
        attempts += 1;

        const aId = Number(a.dataset.objectId);
        const bId = Number(b.dataset.objectId);
        const isMatch = aId === bId;

        if (isMatch) {
            matches += 1;
            streak += 1;
            if (streak > maxStreakSeen) maxStreakSeen = streak;

            score += 10;
            const stepBonus = STREAK_BASE_BONUS * (streak - 1);
            score += stepBonus;

            a.dataset.state = 'matched';
            b.dataset.state = 'matched';
            a.classList.remove('revealed');
            b.classList.remove('revealed');
            a.classList.add('matched');
            b.classList.add('matched');

            soundMatch();
            revealedCards = [];
            updateHUD();
            checkEndOfLevel();
            return;
        }

        // NO MATCH — racha se rompe
        soundError();
        streak = 0;

        const key = canonicalPairKey(aId, bId);
        if (missedPairs.has(key)) {
            attempts += REPEAT_MISS_EXTRA_ATTEMPTS; // +1 intento extra
            score = clampNonNegative(score - REPEAT_MISS_POINT_PENALTY); // -2 pts
            seriousErrors += 1;
        } else {
            missedPairs.add(key);
        }

        [a, b].forEach(card => {
            card.dataset.state = 'pending';
            card.classList.remove('revealed');
            card.classList.add('pending');
        });

        revealedCards = [];
        updateHUD();
    }

    // ===========================
    // Run (crear tablero por grado)
    // ===========================
    function startRun() {
        board.innerHTML = '';
        missedPairs.clear();
        revealedCards = [];
        pendingLock = false;

        score = 0;
        matches = 0;
        attempts = 0;
        streak = 0;
        maxStreakSeen = 0;
        seriousErrors = 0;

        totalCards = gradeConfig[memoryGrade];
        totalPairs = totalCards / 2;
        maxAttempts = Math.ceil(totalPairs * ATTEMPT_FACTOR);

        const columns = computeColumns(totalCards);
        board.style.gridTemplateColumns = `repeat(${columns}, 1fr)`;

        const objectIds = buildObjectIds(totalPairs);

        for (let i = 0; i < totalCards; i++) {
            const card = document.createElement('div');
            card.className = 'card hidden';
            card.dataset.state = 'hidden';
            card.dataset.objectId = String(objectIds[i]);

            // Inner structure for 3D flip
            const cardInner = document.createElement('div');
            cardInner.className = 'card-inner';
            const cardBackFace = document.createElement('div');
            cardBackFace.className = 'card-back-face';
            cardBackFace.textContent = 'K';
            const cardFrontFace = document.createElement('div');
            cardFrontFace.className = 'card-front-face';
            cardInner.appendChild(cardBackFace);
            cardInner.appendChild(cardFrontFace);
            card.appendChild(cardInner);

            card.addEventListener('click', (ev) => {
                ev.stopPropagation();
                if (pendingLock) return;

                // CRÍTICO: si hay 2 pending, limpiarlas PRIMERO
                if (clearPendingCards()) {
                    return; // este click se usó para limpiar, no para abrir
                }

                if (card.dataset.state !== 'hidden') return;
                if (revealedCards.length >= 2) return;

                card.dataset.state = 'revealed';
                card.classList.remove('hidden');
                card.classList.add('revealed');

                // Show thumbnail on front face
                const oid = Number(card.dataset.objectId);
                const cardData = getCardData(oid);
                const frontFace = card.querySelector('.card-front-face');
                if (cardData && cardData.image_url && frontFace) {
                    frontFace.style.backgroundImage = `url('../${cardData.image_url}')`;
                }

                revealedCards.push(card);
                openFocusFor(card);
            });

            board.appendChild(card);
        }

        updateHUD();
    }

    // ===========================
    // Eventos globales
    // ===========================
    overlay.addEventListener('click', () => {
        closeFocus();
        if (revealedCards.length === 2) {
            const [a, b] = revealedCards;
            resolvePair(a, b);
        }
    });

    board.addEventListener('click', (ev) => {
        if (ev.target === board) {
            clearPendingCards();
        }
    });

    // Historial de partidas
    function renderHistory() {
        const history = getHistory();
        if (history.length === 0) {
            historyList.innerHTML = '<p style="text-align:center;color:#888;padding:20px 0;">Aún no hay partidas guardadas.</p>';
            return;
        }
        const grades = { true: '&#10003;', false: '&#10007;' };
        historyList.innerHTML = history.map((h, i) => {
            const d = new Date(h.date);
            const dateStr = d.toLocaleDateString('es', { day: '2-digit', month: 'short', year: 'numeric' });
            const timeStr = d.toLocaleTimeString('es', { hour: '2-digit', minute: '2-digit' });
            const color = h.passed ? '#10b981' : '#ef4444';
            return `<div style="display:grid;grid-template-columns:auto 1fr auto;gap:8px;align-items:center;padding:8px 10px;border-radius:10px;border:1px solid #e5e7eb;background:${h.passed ? '#f0fdf4' : '#fff5f5'};margin-bottom:6px;">
              <span style="font-size:20px;">${h.passed ? '&#127881;' : '&#128561;'}</span>
              <div>
                <div style="font-weight:700;font-size:13px;">Grado ${h.grade} — ${h.pairs}/${h.totalPairs} pares</div>
                <div style="font-size:11px;color:#6b7280;">${dateStr} ${timeStr} &bull; ${h.attempts} intentos &bull; racha ${h.maxStreak}</div>
              </div>
              <div style="font-weight:800;font-size:15px;color:${color};">${h.score} pts</div>
            </div>`;
        }).join('');
    }

    btnHistory.addEventListener('click', () => {
        renderHistory();
        historyOverlay.style.display = 'flex';
    });

    btnHistoryClose.addEventListener('click', () => {
        historyOverlay.style.display = 'none';
    });

    historyOverlay.addEventListener('click', (ev) => {
        if (ev.target === historyOverlay) historyOverlay.style.display = 'none';
    });

    // Arranque
    startRun();

});
</script>

</body>
</html>
